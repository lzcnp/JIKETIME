为什么会有GC ？
    内存固定的，但是使用的的需求越来越多，，，其实就是资源的使用和释放；
多人共享使用仓库
    引用计数：被引用的次数进行+1 标志，到了 0 的时候就进行释放；
    弊端：对象之间调用形成一个环结构，比如是a对象调用b对象，b对象调用c对象，c对象调用a对象，这样一直都是对象之间的计数永不为0；导致了内存泄露

    引用跟踪算法：标记清楚算法；
        （1）遍历所有的可达对象，并在本地内存(native)中分门别类的记下；可达性是怎么实现的？

        （2）清楚掉不可达对象所占内存
     它是并行GC和CMS的基本原理 ：优势是可以处理循环依赖，只扫描部分对象；但是会产生碎片空间，导致大对象生成的时候申请内存不够；

     分代假设：
        1. 年轻代 2，老年代
        年轻代分为               Eden区、 存活区0  存活区1 老年代
        HotSpot默认Eden：Survivor From：Survivor To=8:1:1
        理解一下整个GC的过程：一般的对象都是在自己的方法内部使用，一般会在方法结束之后就释放了就进行了标记，当Eden区 满了之后就会进行一次Minor gc，剩下没有
        被释放的对象 将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间
        然后经历了15次的GC 然后移动到老年代并保存；

        Roots根对象：

        GC算法：
            标记清除算法： 根据可达性分析之后如果对象被标记成可清除那么就直接，就直接清楚，比较的简单，但是会产生很多的不连续的碎片空间，导致大的对象不能好好的保存

            标记复制算法：还是根据可达性的分析之后，当Eden区满了之后就进行一次GC处理，存活的对象就复制到存活区中的一个区，当Eden区再次触发GC的时候就将Eden区和之
            前的存活区中剩下的对象复制到另一个存活区中，并周期的进行，直到达到老年代设定的阈值后就将对象移动到老年区中
                没有标记和清除过程，实现简单，运行高效
                复制过去以后保证空间的连续性，不会出现”碎片“问题

            标记清除整理算法：前面的步骤和标记清楚算法一致但是后续存在一个碎片空间压缩的一个过程；优点就是连续空间

        串行GC SerialGC 串行GC -xx:+UsrSerialGC
            串行GC在年轻代使用的是标记复制算法，在老年代使用的是标记清楚整理算法
            特点：串行过程，都是两个单线程的垃圾回收器，
                 全线线程暂停；
                 效率不高，cpu占用比较高，暂停时间比较长，不适合大的业务系统
        并行GC
         -xx:+UseParallelGC
         -xx:+UseParallelOldGC
         -xx:+UseParallelGC -xx:+UseParallelOldGC
         年轻代和老年代都会导致GC暂停；
         在年轻代使用的是标记复制算法，在老年代使用的是标记清楚整理算法
         -xx:ParallelGCThreads=N来指定GC线程的数量，默认值是cpu的核心数；
         特点：更高的吞吐量，因为是多线程并行处理垃圾，所以暂停时间更短
              在两次GC周期间隔期间没有任何的GC线程运行，所以不耗资源，全部都用来做业务处理；

         吞吐量最优不以为着时间是最短的：


        CMS GC 和G1 GC
        CMS GC(最大标记清除并发收集器)
        年轻代：标记复制算法，老年代主要使用并发（标记-清除算法）

        并行GC 会对老年代后期进行碎片化的整理，这样就会产生一些卡顿的时间，
        特点：1.CMS取消了碎片整理换成了空闲列表来处理内存空间的回收
             2.在垃圾清除的线程处理的时候，不会暂停所有的业务线程，而是业务线程和垃圾回收线程一起并发执行，但是会进行cpu资源的互相竞争；
            如果服务器是多核的，并且主要调优的目的是为了减少GC的停顿延迟，那么使用CMS是很好的，进行老年代回收的时候没可能会伴随多次年轻代的minorGC

            并行GC和并发GC 之间的区别：
                1.相似点：都是使用多线程去处理，
                2.不同点：并发GC是不会暂停所有的业务线程，而是只暂停一部分，但是并行GC就会暂停所有的业务线程去处理GC


